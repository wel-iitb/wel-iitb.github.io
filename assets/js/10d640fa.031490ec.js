"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9175],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>_});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=o.createContext({}),c=function(e){var t=o.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},s=function(e){var t=c(e.components);return o.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=c(n),_=r,m=u["".concat(d,".").concat(_)]||u[_]||p[_]||i;return n?o.createElement(m,a(a({ref:t},s),{},{components:n})):o.createElement(m,a({ref:t},s))}));function _(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=u;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var c=2;c<i;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5794:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=n(7462),r=(n(7294),n(3905));const i={},a=void 0,l={unversionedId:"lab-handouts/lab3_b",id:"lab-handouts/lab3_b",title:"lab3_b",description:"Part-A: Design a 3-to-8 binary decoder by instantiating only 2-to-1 multiplexers.",source:"@site/docs/lab-handouts/lab3_b.mdx",sourceDirName:"lab-handouts",slug:"/lab-handouts/lab3_b",permalink:"/docs/lab-handouts/lab3_b",draft:!1,tags:[],version:"current",frontMatter:{}},d={},c=[{value:"Part-A: Design a 3-to-8 binary decoder by instantiating only 2-to-1 multiplexers.",id:"part-a-design-a-3-to-8-binary-decoder-by-instantiating-only-2-to-1-multiplexers",level:2},{value:"Use below mentioned description of 2x1 Mux to describe Decoder",id:"use-below-mentioned-description-of-2x1-mux-to-describe-decoder",level:3},{value:"Part B: Design fulladder by instantiating only the above designed binary decoder and 8-input or-gate as outlined below.",id:"part-b-design-fulladder-by-instantiating-only-the-above-designed-binary-decoder-and-8-input-or-gate-as-outlined-below",level:2}],s={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"part-a-design-a-3-to-8-binary-decoder-by-instantiating-only-2-to-1-multiplexers"},"Part-A: Design a 3-to-8 binary decoder by instantiating only 2-to-1 multiplexers."),(0,r.kt)("h3",{id:"use-below-mentioned-description-of-2x1-mux-to-describe-decoder"},"Use below mentioned description of 2x1 Mux to describe Decoder"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",1:!0,className:"language-vhdl",metastring:'title="2 x 1 MUX"',title:'"2',x:!0,'MUX"':!0},"library ieee;\nuse ieee.std_logic_1164.all ;\n\nentity mux_2_1 is port ( inp1, inp0 : in std_logic ; sel : in std_logic ;\n       outp  : out std_logic ) ;\nend entity ;\n\narchitecture rch_1_mux_2_1 of mux_2_1 is \nbegin\n  outp <= inp1 when sel='1' else inp0 ;\nend rch_1_mux_2_1 ;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-vhdl",metastring:'title="Skeleton Code for 3-to-8 Decoder"',title:'"Skeleton',Code:!0,for:!0,"3-to-8":!0,'Decoder"':!0},"library ieee; use ieee.std_logic_1164.all ;\n\nentity dcdr_3_8 is port ( inp : in std_logic_vector(2 downto 0) ; \n       outp  : out std_logic_vector(0 to 7) ) ;\nend entity ;\n\narchitecture rch_1_dcdr_3_8 of dcdr_3_8 is \n  component mux_2_1 port ( inp1, inp0 : in std_logic ; sel : in std_logic ; outp : out std_logic ) ;\n  end component ;\n--  ..............\n--  ..............\nbegin\n  -- One suggested collection of mux_2_1 instances that would suffice is along the  following lines\n  -- You are permitted to use any other scheme. However only mux_2_1 instances.\n  -- No other concurrent statement with any logic expression is permitted. If at all, statements\n  -- making logic-less connections among each other is permitted.\n  mx_i_0 : mux_2_1 port map ( ............ ) ;\n  mx_i_1 : mux_2_1 port map ( ............ ) ;\n  mx_i_00 : mux_2_1 port map ( ............ ) ;\n  mx_i_01 : mux_2_1 port map ( ............ ) ;\n  mx_i_10 : mux_2_1 port map ( ............ ) ;\n  mx_i_11 : mux_2_1 port map ( ............ ) ;\n  mx_i_000 : mux_2_1 port map ( ......... , outp(0) ) ;\n  mx_i_001 : mux_2_1 port map ( ......... , outp(1) ) ;\n  mx_i_010 : mux_2_1 port map ( ......... , outp(2) ) ;\n  mx_i_011 : mux_2_1 port map ( ............ ) ;\n  mx_i_100 : mux_2_1 port map ( ............ ) ;\n  mx_i_101 : mux_2_1 port map ( ............ ) ;\n  mx_i_110 : mux_2_1 port map ( ............ ) ;\n  mx_i_111 : mux_2_1 port map ( ......... , outp(7) ) ;\nend rch_1_dcdr_3_8 ;\n")),(0,r.kt)("h2",{id:"part-b-design-fulladder-by-instantiating-only-the-above-designed-binary-decoder-and-8-input-or-gate-as-outlined-below"},"Part B: Design fulladder by instantiating only the above designed binary decoder and 8-input or-gate as outlined below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-vhdl"},"----------------\nlibrary ieee; use ieee.std_logic_1164.all ;\n\nentity or_8 is port ( inp : in std_logic_vector(0 to 7) ;\n       outp  : out std_logic ) ;\nend entity ;\n\narchitecture rch_1_or_8 of or_8 is \nbegin\n  outp <= inp(0) or inp(1) or inp(2) or inp(3) or inp(4) or inp(5) or inp(6) or inp(7) ;\nend rch_1_or_8 ;\n\n----------------\n\nlibrary ieee; use ieee.std_logic_1164.all ;\n\nentity fulladder is port ( a,b,cin : in std_logic ; cout, sum : out std_logic ) ;\nend entity ;\narchitecture rch_1_fulladder of fulladder is \n  component dcdr_3_8 is port ( inp : in std_logic_vector(2 downto 0) ; \n       outp  : out std_logic_vector(0 to 7) ) ;\n  end component ;\n  component or_8 port ( inp : in std_logic_vector(0 to 7) ; \n                        outp : out std_logic ) ;\n  end component ;\n .........\n .........\nbegin\n  dcdr_i0 : dcdr_3_8 port map ( ........... ) ;\n  or_i1 : or_8 port map ( ...... , sum  ) ;\n  or_i2 : or_8 port map ( ...... , cout ) ;\nend rch_1_fulladder ;\n----------------\n\n")))}p.isMDXComponent=!0}}]);